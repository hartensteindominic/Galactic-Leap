<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alien Rift 3D</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #030611;
      --panel: rgba(12, 17, 33, 0.82);
      --accent: #6cffef;
      --danger: #ff4d7a;
      --text: #e6f0ff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 20% 20%, #13254f 0%, transparent 35%),
        radial-gradient(circle at 80% 10%, #3f1f5f 0%, transparent 32%),
        var(--bg);
      font-family: Inter, Segoe UI, sans-serif;
      color: var(--text);
    }

    .shell {
      width: min(980px, 96vw);
      background: linear-gradient(140deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
      border: 1px solid rgba(108, 255, 239, 0.28);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.45), inset 0 0 60px rgba(108, 255, 239, 0.08);
      padding: 16px;
      position: relative;
      overflow: hidden;
    }

    h1 {
      margin: 0 0 10px;
      text-align: center;
      letter-spacing: 0.12em;
      font-size: clamp(1.2rem, 2vw, 1.8rem);
      color: var(--accent);
      text-shadow: 0 0 14px rgba(108, 255, 239, 0.6);
    }

    #game {
      width: 100%;
      height: auto;
      border-radius: 12px;
      background: #000;
      border: 1px solid rgba(108, 255, 239, 0.2);
      display: block;
    }

    .hud {
      position: absolute;
      top: 56px;
      left: 28px;
      background: var(--panel);
      border: 1px solid rgba(108, 255, 239, 0.25);
      border-radius: 10px;
      padding: 10px 14px;
      backdrop-filter: blur(3px);
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .hud span { color: var(--accent); font-weight: 700; }

    .hud small {
      display: block;
      margin-top: 6px;
      font-size: 0.72rem;
      opacity: 0.86;
    }

    .help {
      margin-top: 12px;
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.38);
      border-radius: 16px;
      text-align: center;
      padding: 12px;
      transition: opacity 250ms ease;
    }

    .panel {
      background: rgba(8, 11, 24, 0.94);
      border: 1px solid rgba(108, 255, 239, 0.34);
      border-radius: 14px;
      max-width: 420px;
      padding: 20px;
      box-shadow: 0 0 35px rgba(108, 255, 239, 0.16);
    }

    .panel h2 { color: var(--accent); margin-top: 0; }

    .config {
      text-align: left;
      display: grid;
      gap: 8px;
      margin-top: 10px;
      font-size: 0.86rem;
    }

    .config label { display: grid; gap: 4px; }

    .config input {
      width: 100%;
      border-radius: 6px;
      border: 1px solid rgba(108, 255, 239, 0.2);
      padding: 7px;
      background: rgba(6, 10, 22, 0.92);
      color: var(--text);
    }

    .row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    button {
      margin-top: 10px;
      border: none;
      background: linear-gradient(90deg, #66f5ff, #8d7dff);
      color: #020916;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      letter-spacing: 0.06em;
    }

    .danger { color: var(--danger); font-weight: 700; }
    .hidden { opacity: 0; pointer-events: none; }
  </style>
</head>
<body>
  <div class="shell">
    <h1>ALIEN RIFT 3D</h1>
    <canvas id="game" width="960" height="540" aria-label="Alien Rift game viewport"></canvas>

    <div class="hud">
      Health: <span id="health">100</span><br />
      Score: <span id="score">0</span><br />
      Wave: <span id="wave">1</span><br />
      AI Plan: <span id="aiPlan">adaptive defense</span>
      <small id="aiStatus">AI: local tactical model</small>
    </div>

    <div id="overlay" class="overlay">
      <div class="panel">
        <h2 id="overlayTitle">Defend the Rift</h2>
        <p id="overlayText">WASD / Arrow keys to move, mouse to look, Space to blast aliens. Survive as long as possible.</p>
        <div class="config">
          <div class="row">
            <input type="checkbox" id="useCloudAi" />
            <label for="useCloudAi">Use cloud AI director (optional)</label>
          </div>
          <label>
            AI endpoint
            <input id="aiEndpoint" placeholder="https://api.openai.com/v1/chat/completions" />
          </label>
          <label>
            AI model
            <input id="aiModel" placeholder="gpt-4o-mini" />
          </label>
          <label>
            API key
            <input id="aiApiKey" type="password" placeholder="sk-..." />
          </label>
        </div>
        <button id="startBtn">START MISSION</button>
      </div>
    </div>

    <div class="help">Tip: click inside the game for pointer lock aiming.</div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const startBtn = document.getElementById('startBtn');

    const ui = {
      health: document.getElementById('health'),
      score: document.getElementById('score'),
      wave: document.getElementById('wave'),
      aiPlan: document.getElementById('aiPlan'),
      aiStatus: document.getElementById('aiStatus')
    };

    const aiControls = {
      useCloudAi: document.getElementById('useCloudAi'),
      endpoint: document.getElementById('aiEndpoint'),
      model: document.getElementById('aiModel'),
      apiKey: document.getElementById('aiApiKey')
    };

    const world = {
      player: { x: 0, y: 1.6, z: 0, yaw: 0, speed: 8, health: 100 },
      aliens: [],
      blasts: [],
      stars: [],
      score: 0,
      wave: 1,
      running: false,
      cooldown: 0,
      keys: new Set(),
      time: 0,
      spawnTimer: 0,
      maxSpawnRadius: 54,
      aiDirector: {
        plan: 'adaptive defense',
        aggression: 0.5,
        strafeBias: 0.5,
        retreatHealth: 0.26,
        swarmSpread: 0.5,
        status: 'local tactical model',
        cloudEnabled: false,
        endpoint: '',
        model: 'gpt-4o-mini',
        apiKey: '',
        lastDecisionAt: 0,
        pending: false
      }
    };

    function loadAiConfig() {
      aiControls.useCloudAi.checked = localStorage.getItem('alienRift.useCloudAi') === '1';
      aiControls.endpoint.value = localStorage.getItem('alienRift.endpoint') || 'https://api.openai.com/v1/chat/completions';
      aiControls.model.value = localStorage.getItem('alienRift.model') || 'gpt-4o-mini';
      aiControls.apiKey.value = localStorage.getItem('alienRift.apiKey') || '';
    }

    function syncAiConfigFromForm() {
      world.aiDirector.cloudEnabled = aiControls.useCloudAi.checked;
      world.aiDirector.endpoint = aiControls.endpoint.value.trim();
      world.aiDirector.model = aiControls.model.value.trim() || 'gpt-4o-mini';
      world.aiDirector.apiKey = aiControls.apiKey.value.trim();
      localStorage.setItem('alienRift.useCloudAi', world.aiDirector.cloudEnabled ? '1' : '0');
      localStorage.setItem('alienRift.endpoint', world.aiDirector.endpoint);
      localStorage.setItem('alienRift.model', world.aiDirector.model);
      localStorage.setItem('alienRift.apiKey', world.aiDirector.apiKey);
    }

    for (let i = 0; i < 180; i++) {
      world.stars.push({
        x: (Math.random() - 0.5) * 200,
        y: 20 + Math.random() * 110,
        z: 20 + Math.random() * 220,
        r: Math.random() * 1.8 + 0.3
      });
    }

    function resetGame() {
      world.player.x = 0;
      world.player.z = 0;
      world.player.yaw = 0;
      world.player.health = 100;
      world.aliens = [];
      world.blasts = [];
      world.score = 0;
      world.wave = 1;
      world.time = 0;
      world.spawnTimer = 0;
      world.cooldown = 0;
      world.aiDirector.plan = 'adaptive defense';
      world.aiDirector.status = world.aiDirector.cloudEnabled ? 'cloud model ready' : 'local tactical model';
      world.aiDirector.lastDecisionAt = 0;
      world.aiDirector.pending = false;
      updateHud();
    }

    function updateHud() {
      ui.health.textContent = Math.max(0, Math.round(world.player.health));
      ui.score.textContent = world.score;
      ui.wave.textContent = world.wave;
      ui.aiPlan.textContent = world.aiDirector.plan;
      ui.aiStatus.textContent = `AI: ${world.aiDirector.status}`;
      ui.health.style.color = world.player.health <= 30 ? '#ff4d7a' : '#6cffef';
    }

    function spawnAlien() {
      const angle = Math.random() * Math.PI * 2;
      const radius = 24 + Math.random() * world.maxSpawnRadius;
      const size = 0.8 + Math.random() * 1.4;
      world.aliens.push({
        x: world.player.x + Math.cos(angle) * radius,
        y: 1.2 + Math.random() * 0.8,
        z: world.player.z + Math.sin(angle) * radius,
        size,
        speed: 1.3 + Math.random() * 0.9 + world.wave * 0.08,
        hp: 1 + Math.floor(world.wave / 3),
        bob: Math.random() * Math.PI * 2,
        heading: Math.random() * Math.PI * 2,
        decisionTimer: Math.random() * 1.2,
        state: 'seek',
        fireCooldown: 0.4 + Math.random() * 0.7,
        bravery: 0.35 + Math.random() * 0.55
      });
    }

    async function requestCloudDecision() {
      const ai = world.aiDirector;
      if (!ai.cloudEnabled || !ai.endpoint || !ai.apiKey || ai.pending) return;
      ai.pending = true;
      ai.status = 'thinking...';
      try {
        const response = await fetch(ai.endpoint, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: `Bearer ${ai.apiKey}`
          },
          body: JSON.stringify({
            model: ai.model,
            messages: [
              { role: 'system', content: 'Return strict JSON with keys: plan, aggression, strafeBias, retreatHealth, swarmSpread. Values in [0,1] except plan short text.' },
              {
                role: 'user',
                content: `Wave=${world.wave}, health=${Math.round(world.player.health)}, score=${world.score}, aliens=${world.aliens.length}`
              }
            ],
            response_format: { type: 'json_object' },
            temperature: 0.3
          })
        });
        if (!response.ok) throw new Error('bad response');
        const data = await response.json();
        const raw = data.choices?.[0]?.message?.content || '{}';
        const parsed = JSON.parse(raw);
        applyAiDecision(parsed, true);
        ai.status = 'cloud tactical stream';
      } catch (_error) {
        ai.status = 'cloud unavailable, using local model';
      } finally {
        ai.pending = false;
        updateHud();
      }
    }

    function applyAiDecision(decision, fromCloud = false) {
      const ai = world.aiDirector;
      if (decision.plan) ai.plan = String(decision.plan).slice(0, 36);
      for (const [key, fallback] of Object.entries({ aggression: 0.5, strafeBias: 0.5, retreatHealth: 0.26, swarmSpread: 0.5 })) {
        const value = Number(decision[key]);
        if (Number.isFinite(value)) ai[key] = Math.max(0, Math.min(1, value));
        else ai[key] = ai[key] ?? fallback;
      }
      if (!fromCloud) ai.status = 'local tactical model';
    }

    function updateLocalDirector() {
      const pressure = Math.min(1, world.aliens.length / (10 + world.wave));
      const hpRisk = 1 - Math.max(0, Math.min(1, world.player.health / 100));
      applyAiDecision({
        plan: hpRisk > 0.55 ? 'fallback and kite' : pressure > 0.62 ? 'contain the swarm' : 'adaptive defense',
        aggression: 0.42 + world.wave * 0.03 - hpRisk * 0.25,
        strafeBias: 0.35 + pressure * 0.42,
        retreatHealth: 0.2 + hpRisk * 0.35,
        swarmSpread: 0.35 + pressure * 0.5
      });
    }

    function fireBlast() {
      if (world.cooldown > 0) return;
      world.cooldown = 0.23;
      const dirX = Math.sin(world.player.yaw);
      const dirZ = Math.cos(world.player.yaw);
      world.blasts.push({
        x: world.player.x + dirX * 1,
        y: 1.5,
        z: world.player.z + dirZ * 1,
        vx: dirX * 38,
        vz: dirZ * 38,
        life: 1.1
      });
    }

    function update(dt) {
      if (!world.running) return;
      world.time += dt;
      world.cooldown = Math.max(0, world.cooldown - dt);

      const moveX = (world.keys.has('d') || world.keys.has('arrowright') ? 1 : 0) - (world.keys.has('a') || world.keys.has('arrowleft') ? 1 : 0);
      const moveZ = (world.keys.has('w') || world.keys.has('arrowup') ? 1 : 0) - (world.keys.has('s') || world.keys.has('arrowdown') ? 1 : 0);

      if (moveX || moveZ) {
        const len = Math.hypot(moveX, moveZ) || 1;
        const localX = moveX / len;
        const localZ = moveZ / len;
        const sin = Math.sin(world.player.yaw);
        const cos = Math.cos(world.player.yaw);
        world.player.x += (localX * cos + localZ * sin) * dt * world.player.speed;
        world.player.z += (localZ * cos - localX * sin) * dt * world.player.speed;
      }

      world.spawnTimer -= dt;
      if (world.time - world.aiDirector.lastDecisionAt > 4.2) {
        world.aiDirector.lastDecisionAt = world.time;
        updateLocalDirector();
        requestCloudDecision();
      }
      const desired = Math.min(8 + world.wave * 2, 28);
      if (world.spawnTimer <= 0 && world.aliens.length < desired) {
        spawnAlien();
        world.spawnTimer = Math.max(0.2, 1.2 - world.wave * 0.05);
      }

      for (const alien of world.aliens) {
        const dx = world.player.x - alien.x;
        const dz = world.player.z - alien.z;
        const dist = Math.hypot(dx, dz) || 0.001;
        alien.bob += dt * 4;
        alien.y = 1.2 + Math.sin(alien.bob) * 0.25;
        alien.decisionTimer -= dt;
        alien.fireCooldown -= dt;
        if (alien.decisionTimer <= 0) {
          const retreatThreshold = world.aiDirector.retreatHealth * (0.8 + (1 - alien.bravery) * 0.4) * 100;
          if (world.player.health < retreatThreshold && dist < 9) alien.state = 'retreat';
          else if (dist < 7 && Math.random() < world.aiDirector.strafeBias) alien.state = 'strafe';
          else if (dist > 12 || Math.random() < world.aiDirector.aggression) alien.state = 'seek';
          else alien.state = 'flank';
          alien.decisionTimer = 0.4 + Math.random() * 1.1;
        }

        const spread = world.aiDirector.swarmSpread * 2.8;
        let avoidX = 0;
        let avoidZ = 0;
        for (const other of world.aliens) {
          if (other === alien) continue;
          const ox = alien.x - other.x;
          const oz = alien.z - other.z;
          const od = Math.hypot(ox, oz) || 0.001;
          if (od < 3 + spread) {
            avoidX += (ox / od) * (1 - od / (3 + spread));
            avoidZ += (oz / od) * (1 - od / (3 + spread));
          }
        }

        let moveDirX = dx / dist;
        let moveDirZ = dz / dist;
        if (alien.state === 'strafe') {
          moveDirX = -moveDirZ;
          moveDirZ = dx / dist;
        } else if (alien.state === 'retreat') {
          moveDirX *= -1;
          moveDirZ *= -1;
        } else if (alien.state === 'flank') {
          const flankDir = alien.heading > Math.PI ? -1 : 1;
          moveDirX = (dx / dist) * 0.4 + (-moveDirZ * flankDir) * 0.7;
          moveDirZ = (dz / dist) * 0.4 + (moveDirX * flankDir) * 0.7;
        }

        alien.x += (moveDirX + avoidX * 0.7) * alien.speed * dt;
        alien.z += (moveDirZ + avoidZ * 0.7) * alien.speed * dt;

        if (dist < 1.5) {
          world.player.health -= dt * (6 + world.wave * 0.4);
        } else if (dist < 13 && alien.fireCooldown <= 0 && world.wave >= 2) {
          world.player.health -= dt * (0.7 + world.wave * 0.07);
          alien.fireCooldown = 1.2 + Math.random() * 1.1;
        }
      }

      for (let i = world.blasts.length - 1; i >= 0; i--) {
        const b = world.blasts[i];
        b.life -= dt;
        b.x += b.vx * dt;
        b.z += b.vz * dt;
        if (b.life <= 0) {
          world.blasts.splice(i, 1);
          continue;
        }

        for (let j = world.aliens.length - 1; j >= 0; j--) {
          const a = world.aliens[j];
          const hit = Math.hypot(a.x - b.x, a.z - b.z) < (a.size * 0.7 + 0.55);
          if (hit) {
            a.hp -= 1;
            world.blasts.splice(i, 1);
            if (a.hp <= 0) {
              world.aliens.splice(j, 1);
              world.score += 10;
              if (world.score % 120 === 0) world.wave += 1;
            }
            break;
          }
        }
      }

      if (world.player.health <= 0) {
        endGame();
      }

      updateHud();
    }

    function projectPoint(x, y, z) {
      const dx = x - world.player.x;
      const dy = y - world.player.y;
      const dz = z - world.player.z;
      const sin = Math.sin(-world.player.yaw);
      const cos = Math.cos(-world.player.yaw);
      const rx = dx * cos - dz * sin;
      const rz = dx * sin + dz * cos;
      if (rz <= 0.3) return null;
      const f = 620 / rz;
      return {
        x: canvas.width / 2 + rx * f,
        y: canvas.height / 2 - dy * f,
        scale: f,
        depth: rz
      };
    }

    function draw() {
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#020714');
      grad.addColorStop(0.7, '#0d1329');
      grad.addColorStop(1, '#05070f');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      for (const s of world.stars) {
        const p = projectPoint(s.x, s.y, world.player.z + s.z);
        if (!p) continue;
        const alpha = Math.min(1, 170 / p.depth);
        ctx.fillStyle = `rgba(200,240,255,${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, s.r * (p.scale * 0.007), 0, Math.PI * 2);
        ctx.fill();
      }

      ctx.strokeStyle = 'rgba(108,255,239,0.13)';
      ctx.lineWidth = 1;
      for (let i = -18; i <= 18; i++) {
        drawGroundLine(i, -60, i, 60);
        drawGroundLine(-60, i, 60, i);
      }

      const renderables = [];

      for (const alien of world.aliens) {
        const p = projectPoint(alien.x, alien.y, alien.z);
        if (!p) continue;
        renderables.push({ type: 'alien', p, alien });
      }

      for (const b of world.blasts) {
        const p = projectPoint(b.x, b.y, b.z);
        if (!p) continue;
        renderables.push({ type: 'blast', p, blast: b });
      }

      renderables.sort((a, b) => b.p.depth - a.p.depth);

      for (const r of renderables) {
        if (r.type === 'alien') {
          const sizePx = r.alien.size * r.p.scale;
          const glow = Math.min(0.9, 2 / r.p.depth);
          ctx.fillStyle = `rgba(118,255,163,${0.4 + glow * 0.45})`;
          ctx.beginPath();
          ctx.ellipse(r.p.x, r.p.y - sizePx * 0.25, sizePx * 0.5, sizePx * 0.68, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.fillStyle = 'rgba(40,255,120,0.7)';
          ctx.beginPath();
          ctx.arc(r.p.x - sizePx * 0.15, r.p.y - sizePx * 0.3, Math.max(2, sizePx * 0.07), 0, Math.PI * 2);
          ctx.arc(r.p.x + sizePx * 0.15, r.p.y - sizePx * 0.3, Math.max(2, sizePx * 0.07), 0, Math.PI * 2);
          ctx.fill();
        } else {
          const size = Math.max(2, r.p.scale * 0.08);
          ctx.fillStyle = 'rgba(170,240,255,0.95)';
          ctx.beginPath();
          ctx.arc(r.p.x, r.p.y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      drawCrosshair();
    }

    function drawGroundLine(x1, z1, x2, z2) {
      const p1 = projectPoint(x1, 0, z1);
      const p2 = projectPoint(x2, 0, z2);
      if (!p1 || !p2) return;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    function drawCrosshair() {
      ctx.strokeStyle = 'rgba(190,255,249,0.9)';
      ctx.lineWidth = 1.5;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      ctx.beginPath();
      ctx.moveTo(cx - 10, cy);
      ctx.lineTo(cx + 10, cy);
      ctx.moveTo(cx, cy - 10);
      ctx.lineTo(cx, cy + 10);
      ctx.stroke();
    }

    function endGame() {
      world.running = false;
      document.exitPointerLock?.();
      overlayTitle.textContent = 'Mission Failed';
      overlayText.innerHTML = `You scored <span class="danger">${world.score}</span> points and reached wave ${world.wave}.`;
      startBtn.textContent = 'RETRY';
      overlay.classList.remove('hidden');
    }

    function gameLoop(last = performance.now()) {
      const tick = (now) => {
        const dt = Math.min(0.032, (now - last) / 1000);
        last = now;
        update(dt);
        draw();
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }

    startBtn.addEventListener('click', () => {
      syncAiConfigFromForm();
      overlay.classList.add('hidden');
      resetGame();
      world.running = true;
      canvas.requestPointerLock?.();
    });

    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      world.keys.add(key);
      if (key === ' ' && world.running) {
        e.preventDefault();
        fireBlast();
      }
    });

    window.addEventListener('keyup', (e) => {
      world.keys.delete(e.key.toLowerCase());
    });

    document.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === canvas && world.running) {
        world.player.yaw += e.movementX * 0.0028;
      }
    });

    canvas.addEventListener('click', () => {
      if (world.running) canvas.requestPointerLock?.();
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0 && world.running) fireBlast();
    });

    resetGame();
    loadAiConfig();
    syncAiConfigFromForm();
    draw();
    gameLoop();
  </script>
</body>
</html>
