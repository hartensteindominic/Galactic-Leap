<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Alien Dessert Rift 3D</title>
  <style>
    :root {
      color-scheme: dark;
      --bg: #030611;
      --panel: rgba(12, 17, 33, 0.82);
      --accent: #6cffef;
      --danger: #ff4d7a;
      --text: #e6f0ff;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      min-height: 100vh;
      display: grid;
      place-items: center;
      background:
        radial-gradient(circle at 20% 20%, #13254f 0%, transparent 35%),
        radial-gradient(circle at 80% 10%, #3f1f5f 0%, transparent 32%),
        var(--bg);
      font-family: Inter, Segoe UI, sans-serif;
      color: var(--text);
    }

    .shell {
      width: min(980px, 96vw);
      background: linear-gradient(140deg, rgba(255,255,255,0.02), rgba(255,255,255,0));
      border: 1px solid rgba(108, 255, 239, 0.28);
      border-radius: 16px;
      box-shadow: 0 18px 45px rgba(0, 0, 0, 0.45), inset 0 0 60px rgba(108, 255, 239, 0.08);
      padding: 16px;
      position: relative;
      overflow: hidden;
    }

    h1 {
      margin: 0 0 10px;
      text-align: center;
      letter-spacing: 0.12em;
      font-size: clamp(1.2rem, 2vw, 1.8rem);
      color: var(--accent);
      text-shadow: 0 0 14px rgba(108, 255, 239, 0.6);
    }

    #game {
      width: 100%;
      height: auto;
      border-radius: 12px;
      background: #000;
      border: 1px solid rgba(108, 255, 239, 0.2);
      display: block;
    }

    .hud {
      position: absolute;
      top: 56px;
      left: 28px;
      background: var(--panel);
      border: 1px solid rgba(108, 255, 239, 0.25);
      border-radius: 10px;
      padding: 10px 14px;
      backdrop-filter: blur(3px);
      line-height: 1.5;
      font-size: 0.95rem;
    }

    .hud span { color: var(--accent); font-weight: 700; }

    .help {
      margin-top: 12px;
      text-align: center;
      font-size: 0.9rem;
      opacity: 0.9;
    }

    .overlay {
      position: absolute;
      inset: 0;
      display: grid;
      place-items: center;
      background: rgba(0, 0, 0, 0.38);
      border-radius: 16px;
      text-align: center;
      padding: 12px;
      transition: opacity 250ms ease;
    }

    .panel {
      background: rgba(8, 11, 24, 0.94);
      border: 1px solid rgba(108, 255, 239, 0.34);
      border-radius: 14px;
      max-width: 420px;
      padding: 20px;
      box-shadow: 0 0 35px rgba(108, 255, 239, 0.16);
    }

    .panel h2 { color: var(--accent); margin-top: 0; }

    button {
      margin-top: 10px;
      border: none;
      background: linear-gradient(90deg, #66f5ff, #8d7dff);
      color: #020916;
      font-weight: 700;
      padding: 10px 16px;
      border-radius: 8px;
      cursor: pointer;
      letter-spacing: 0.06em;
    }

    .danger { color: var(--danger); font-weight: 700; }
    .hidden { opacity: 0; pointer-events: none; }
  </style>
</head>
<body>
  <div class="shell">
    <h1>ALIEN DESSERT RIFT 3D</h1>
    <canvas id="game" width="960" height="540" aria-label="Alien Rift game viewport"></canvas>

    <div class="hud">
      Health: <span id="health">100</span><br />
      Score: <span id="score">0</span><br />
      Wave: <span id="wave">1</span><br />
      AI Core: <span id="aiState">Balanced</span>
    </div>

    <div id="overlay" class="overlay">
      <div class="panel">
        <h2 id="overlayTitle">Defend the Rift</h2>
        <p id="overlayText">WASD / Arrow keys to move, mouse to look, Space to blast aliens. Survive the glowing dessert dunes while super-realistic alien AI agents hunt with lifelike movement.</p>
        <button id="startBtn">START MISSION</button>
      </div>
    </div>

    <div class="help">Tip: click inside the game for pointer lock aiming.</div>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const overlay = document.getElementById('overlay');
    const overlayTitle = document.getElementById('overlayTitle');
    const overlayText = document.getElementById('overlayText');
    const startBtn = document.getElementById('startBtn');

    const ui = {
      health: document.getElementById('health'),
      score: document.getElementById('score'),
      wave: document.getElementById('wave'),
      aiState: document.getElementById('aiState')
    };

    const world = {
      player: { x: 0, y: 1.6, z: 0, yaw: 0, speed: 8, health: 100 },
      aliens: [],
      blasts: [],
      stars: [],
      score: 0,
      wave: 1,
      running: false,
      cooldown: 0,
      keys: new Set(),
      time: 0,
      spawnTimer: 0,
      maxSpawnRadius: 54,
      ai: {
        skill: 0.5,
        aggression: 1,
        directive: 'Balanced',
        analysisWindow: 0,
        scoreSnapshot: 0
      }
    };

    for (let i = 0; i < 180; i++) {
      world.stars.push({
        x: (Math.random() - 0.5) * 200,
        y: 20 + Math.random() * 110,
        z: 20 + Math.random() * 220,
        r: Math.random() * 1.8 + 0.3,
        tint: Math.random() < 0.4 ? '255,190,140' : '255,236,206'
      });
    }

    function resetGame() {
      world.player.x = 0;
      world.player.z = 0;
      world.player.yaw = 0;
      world.player.health = 100;
      world.aliens = [];
      world.blasts = [];
      world.score = 0;
      world.wave = 1;
      world.time = 0;
      world.spawnTimer = 0;
      world.cooldown = 0;
      world.ai.skill = 0.5;
      world.ai.aggression = 1;
      world.ai.directive = 'Balanced';
      world.ai.analysisWindow = 0;
      world.ai.scoreSnapshot = 0;
      updateHud();
    }

    function updateHud() {
      ui.health.textContent = Math.max(0, Math.round(world.player.health));
      ui.score.textContent = world.score;
      ui.wave.textContent = world.wave;
      ui.aiState.textContent = world.ai.directive;
      ui.health.style.color = world.player.health <= 30 ? '#ff4d7a' : '#6cffef';
      ui.aiState.style.color = world.ai.skill >= 0.72 ? '#ff8aa8' : world.ai.skill <= 0.3 ? '#9efc6a' : '#6cffef';
    }

    function spawnAlien() {
      const angle = Math.random() * Math.PI * 2;
      const radius = 24 + Math.random() * world.maxSpawnRadius;
      const size = 0.8 + Math.random() * 1.4;
      const heading = Math.random() * Math.PI * 2;
      world.aliens.push({
        x: world.player.x + Math.cos(angle) * radius,
        y: 1.2 + Math.random() * 0.8,
        z: world.player.z + Math.sin(angle) * radius,
        size,
        speed: (1.3 + Math.random() * 0.9 + world.wave * 0.08) * (0.85 + world.ai.aggression * 0.25),
        topSpeed: 6.2 + Math.random() * 3,
        vx: Math.cos(heading) * 0.5,
        vz: Math.sin(heading) * 0.5,
        heading,
        turnRate: 1.5 + Math.random() * 1.2,
        hp: 1 + Math.floor(world.wave / 3),
        bob: Math.random() * Math.PI * 2,
        strafePhase: Math.random() * Math.PI * 2,
        strafeStrength: 0.45 + Math.random() * 0.7,
        gaitPhase: Math.random() * Math.PI * 2,
        armSwing: 0,
        legSwing: 0
      });
    }

    function wrapAngle(a) {
      while (a > Math.PI) a -= Math.PI * 2;
      while (a < -Math.PI) a += Math.PI * 2;
      return a;
    }

    function updateOpenSourceAi(dt) {
      world.ai.analysisWindow += dt;
      if (world.ai.analysisWindow < 2) return;

      const scoreDelta = world.score - world.ai.scoreSnapshot;
      world.ai.scoreSnapshot = world.score;
      world.ai.analysisWindow = 0;

      const healthPressure = 1 - (world.player.health / 100);
      const eliminationRate = Math.min(1, scoreDelta / 30);
      const crowding = Math.min(1, world.aliens.length / 28);
      const challengeIndex = 0.55 * eliminationRate - 0.35 * healthPressure + 0.25 * crowding;

      world.ai.skill = Math.max(0.12, Math.min(0.9, world.ai.skill + challengeIndex * 0.12));
      world.ai.aggression = 0.78 + world.ai.skill * 0.74;

      if (world.ai.skill >= 0.72) {
        world.ai.directive = 'Predator';
      } else if (world.ai.skill <= 0.3) {
        world.ai.directive = 'Recovery';
      } else {
        world.ai.directive = 'Balanced';
      }
    }

    function fireBlast() {
      if (world.cooldown > 0) return;
      world.cooldown = 0.23;
      const dirX = Math.sin(world.player.yaw);
      const dirZ = Math.cos(world.player.yaw);
      world.blasts.push({
        x: world.player.x + dirX * 1,
        y: 1.5,
        z: world.player.z + dirZ * 1,
        vx: dirX * 38,
        vz: dirZ * 38,
        life: 1.1
      });
    }

    function update(dt) {
      if (!world.running) return;
      world.time += dt;
      world.cooldown = Math.max(0, world.cooldown - dt);
      updateOpenSourceAi(dt);

      const moveX = (world.keys.has('d') || world.keys.has('arrowright') ? 1 : 0) - (world.keys.has('a') || world.keys.has('arrowleft') ? 1 : 0);
      const moveZ = (world.keys.has('w') || world.keys.has('arrowup') ? 1 : 0) - (world.keys.has('s') || world.keys.has('arrowdown') ? 1 : 0);

      if (moveX || moveZ) {
        const len = Math.hypot(moveX, moveZ) || 1;
        const localX = moveX / len;
        const localZ = moveZ / len;
        const sin = Math.sin(world.player.yaw);
        const cos = Math.cos(world.player.yaw);
        world.player.x += (localX * cos + localZ * sin) * dt * world.player.speed;
        world.player.z += (localZ * cos - localX * sin) * dt * world.player.speed;
      }

      world.spawnTimer -= dt;
      const desired = Math.min(Math.round(7 + world.wave * (1.6 + world.ai.skill)), 30);
      if (world.spawnTimer <= 0 && world.aliens.length < desired) {
        spawnAlien();
        world.spawnTimer = Math.max(0.15, 1.24 - world.wave * 0.045 - world.ai.skill * 0.34);
      }

      for (const alien of world.aliens) {
        const dx = world.player.x - alien.x;
        const dz = world.player.z - alien.z;
        const dist = Math.hypot(dx, dz) || 0.001;
        alien.bob += dt * 4;
        alien.strafePhase += dt * (1.8 + world.ai.skill * 2.3);
        alien.gaitPhase += dt * (4.5 + alien.speed * 0.32);
        alien.y = 1.2 + Math.sin(alien.bob) * 0.25;
        const nx = dx / dist;
        const nz = dz / dist;
        const sideX = -nz;
        const sideZ = nx;
        const strafe = Math.sin(alien.strafePhase) * alien.strafeStrength * world.ai.skill;
        const desiredX = nx + sideX * strafe;
        const desiredZ = nz + sideZ * strafe;
        const targetHeading = Math.atan2(desiredZ, desiredX);
        const headingDelta = wrapAngle(targetHeading - alien.heading);
        alien.heading += Math.max(-alien.turnRate * dt, Math.min(alien.turnRate * dt, headingDelta));

        let avoidX = 0;
        let avoidZ = 0;
        for (const other of world.aliens) {
          if (other === alien) continue;
          const ox = alien.x - other.x;
          const oz = alien.z - other.z;
          const d = Math.hypot(ox, oz) || 0.001;
          if (d < 2.3) {
            const push = (2.3 - d) / 2.3;
            avoidX += (ox / d) * push;
            avoidZ += (oz / d) * push;
          }
        }

        const accel = alien.speed * (0.9 + world.ai.skill * 0.8);
        alien.vx += (Math.cos(alien.heading) * accel + avoidX * 5 - alien.vx * 1.9) * dt;
        alien.vz += (Math.sin(alien.heading) * accel + avoidZ * 5 - alien.vz * 1.9) * dt;
        const vel = Math.hypot(alien.vx, alien.vz) || 0.001;
        if (vel > alien.topSpeed) {
          alien.vx = (alien.vx / vel) * alien.topSpeed;
          alien.vz = (alien.vz / vel) * alien.topSpeed;
        }

        alien.x += alien.vx * dt;
        alien.z += alien.vz * dt;
        alien.legSwing = Math.sin(alien.gaitPhase) * 0.75;
        alien.armSwing = Math.sin(alien.gaitPhase + Math.PI / 2) * 0.55;

        if (dist < 1.5) {
          world.player.health -= dt * (6 + world.wave * 0.4);
        }
      }

      for (let i = world.blasts.length - 1; i >= 0; i--) {
        const b = world.blasts[i];
        b.life -= dt;
        b.x += b.vx * dt;
        b.z += b.vz * dt;
        if (b.life <= 0) {
          world.blasts.splice(i, 1);
          continue;
        }

        for (let j = world.aliens.length - 1; j >= 0; j--) {
          const a = world.aliens[j];
          const hit = Math.hypot(a.x - b.x, a.z - b.z) < (a.size * 0.7 + 0.55);
          if (hit) {
            a.hp -= 1;
            world.blasts.splice(i, 1);
            if (a.hp <= 0) {
              world.aliens.splice(j, 1);
              world.score += 10;
              if (world.score % 120 === 0) world.wave += 1;
            }
            break;
          }
        }
      }

      if (world.player.health <= 0) {
        endGame();
      }

      updateHud();
    }

    function projectPoint(x, y, z) {
      const dx = x - world.player.x;
      const dy = y - world.player.y;
      const dz = z - world.player.z;
      const sin = Math.sin(-world.player.yaw);
      const cos = Math.cos(-world.player.yaw);
      const rx = dx * cos - dz * sin;
      const rz = dx * sin + dz * cos;
      if (rz <= 0.3) return null;
      const f = 620 / rz;
      return {
        x: canvas.width / 2 + rx * f,
        y: canvas.height / 2 - dy * f,
        scale: f,
        depth: rz
      };
    }

    function draw() {
      const grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
      grad.addColorStop(0, '#3c1f17');
      grad.addColorStop(0.62, '#9a5d2c');
      grad.addColorStop(1, '#25120e');
      ctx.fillStyle = grad;
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      drawDesertMist();

      for (const s of world.stars) {
        const p = projectPoint(s.x, s.y, world.player.z + s.z);
        if (!p) continue;
        const alpha = Math.min(1, 170 / p.depth);
        ctx.fillStyle = `rgba(${s.tint},${alpha})`;
        ctx.beginPath();
        ctx.arc(p.x, p.y, s.r * (p.scale * 0.007), 0, Math.PI * 2);
        ctx.fill();
      }

      drawDessertDunes();

      const renderables = [];

      for (const alien of world.aliens) {
        const p = projectPoint(alien.x, alien.y, alien.z);
        if (!p) continue;
        renderables.push({ type: 'alien', p, alien });
      }

      for (const b of world.blasts) {
        const p = projectPoint(b.x, b.y, b.z);
        if (!p) continue;
        renderables.push({ type: 'blast', p, blast: b });
      }

      renderables.sort((a, b) => b.p.depth - a.p.depth);

      for (const r of renderables) {
        if (r.type === 'alien') {
          drawRealisticAlienAgent(r);
        } else {
          const size = Math.max(2, r.p.scale * 0.08);
          ctx.fillStyle = 'rgba(170,240,255,0.95)';
          ctx.beginPath();
          ctx.arc(r.p.x, r.p.y, size, 0, Math.PI * 2);
          ctx.fill();
        }
      }

      drawCrosshair();
    }

    function drawDesertMist() {
      const y = canvas.height * 0.38;
      const mist = ctx.createLinearGradient(0, y, 0, canvas.height);
      mist.addColorStop(0, 'rgba(255,173,99,0)');
      mist.addColorStop(1, 'rgba(255,170,92,0.21)');
      ctx.fillStyle = mist;
      ctx.fillRect(0, y, canvas.width, canvas.height - y);
    }

    function drawDessertDunes() {
      ctx.strokeStyle = 'rgba(255,208,150,0.18)';
      ctx.lineWidth = 1;
      for (let i = -18; i <= 18; i++) {
        drawGroundLine(i, -60, i, 60);
      }
      for (let z = -55; z <= 60; z += 4) {
        let first = true;
        ctx.beginPath();
        for (let x = -70; x <= 70; x += 3) {
          const duneY = Math.sin((x + z + world.time * 2) * 0.11) * 0.35 + Math.cos((x - z) * 0.15) * 0.2;
          const p = projectPoint(x, duneY, z);
          if (!p) continue;
          if (first) {
            ctx.moveTo(p.x, p.y);
            first = false;
          } else {
            ctx.lineTo(p.x, p.y);
          }
        }
        ctx.stroke();
      }
    }

    function drawRealisticAlienAgent(r) {
      const sizePx = r.alien.size * r.p.scale;
      const glow = Math.min(0.9, 2 / r.p.depth);
      const dir = Math.cos(r.alien.heading - world.player.yaw);
      const lean = Math.sin(r.alien.heading - world.player.yaw) * sizePx * 0.06;

      ctx.fillStyle = `rgba(35,27,22,${0.28 + glow * 0.2})`;
      ctx.beginPath();
      ctx.ellipse(r.p.x, r.p.y + sizePx * 0.65, sizePx * 0.42, sizePx * 0.13, 0, 0, Math.PI * 2);
      ctx.fill();

      const bodyGrad = ctx.createLinearGradient(r.p.x, r.p.y - sizePx * 0.8, r.p.x, r.p.y + sizePx * 0.4);
      bodyGrad.addColorStop(0, 'rgba(214,226,235,0.95)');
      bodyGrad.addColorStop(0.55, 'rgba(148,166,181,0.95)');
      bodyGrad.addColorStop(1, 'rgba(80,94,109,0.95)');
      ctx.fillStyle = bodyGrad;
      ctx.beginPath();
      ctx.roundRect(r.p.x - sizePx * 0.22 + lean, r.p.y - sizePx * 0.48, sizePx * 0.44, sizePx * 0.72, sizePx * 0.16);
      ctx.fill();

      ctx.fillStyle = 'rgba(75,93,112,0.95)';
      const armOffset = r.alien.armSwing * sizePx * 0.15;
      ctx.fillRect(r.p.x - sizePx * 0.35 + lean, r.p.y - sizePx * 0.4 + armOffset, sizePx * 0.09, sizePx * 0.45);
      ctx.fillRect(r.p.x + sizePx * 0.26 + lean, r.p.y - sizePx * 0.4 - armOffset, sizePx * 0.09, sizePx * 0.45);

      const legOffset = r.alien.legSwing * sizePx * 0.16;
      ctx.fillRect(r.p.x - sizePx * 0.15 + lean, r.p.y + sizePx * 0.18 + legOffset, sizePx * 0.1, sizePx * 0.45);
      ctx.fillRect(r.p.x + sizePx * 0.05 + lean, r.p.y + sizePx * 0.18 - legOffset, sizePx * 0.1, sizePx * 0.45);

      const headGrad = ctx.createRadialGradient(r.p.x + lean - sizePx * 0.05, r.p.y - sizePx * 0.68, sizePx * 0.05, r.p.x + lean, r.p.y - sizePx * 0.63, sizePx * 0.24);
      headGrad.addColorStop(0, 'rgba(250,252,255,0.98)');
      headGrad.addColorStop(1, 'rgba(120,140,155,0.95)');
      ctx.fillStyle = headGrad;
      ctx.beginPath();
      ctx.ellipse(r.p.x + lean, r.p.y - sizePx * 0.62, sizePx * 0.2, sizePx * 0.24, 0, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = `rgba(93,255,227,${0.65 + glow * 0.25})`;
      const eyeSpread = sizePx * 0.06 * (0.5 + Math.max(0.2, dir));
      const eyeSize = Math.max(1.4, sizePx * 0.02);
      ctx.beginPath();
      ctx.arc(r.p.x + lean - eyeSpread, r.p.y - sizePx * 0.64, eyeSize, 0, Math.PI * 2);
      ctx.arc(r.p.x + lean + eyeSpread, r.p.y - sizePx * 0.64, eyeSize, 0, Math.PI * 2);
      ctx.fill();
    }

    function drawGroundLine(x1, z1, x2, z2) {
      const p1 = projectPoint(x1, 0, z1);
      const p2 = projectPoint(x2, 0, z2);
      if (!p1 || !p2) return;
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    function drawCrosshair() {
      ctx.strokeStyle = 'rgba(190,255,249,0.9)';
      ctx.lineWidth = 1.5;
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      ctx.beginPath();
      ctx.moveTo(cx - 10, cy);
      ctx.lineTo(cx + 10, cy);
      ctx.moveTo(cx, cy - 10);
      ctx.lineTo(cx, cy + 10);
      ctx.stroke();
    }

    function endGame() {
      world.running = false;
      document.exitPointerLock?.();
      overlayTitle.textContent = 'Mission Failed';
      overlayText.innerHTML = `You scored <span class="danger">${world.score}</span> points and reached wave ${world.wave}.`;
      startBtn.textContent = 'RETRY';
      overlay.classList.remove('hidden');
    }

    function gameLoop(last = performance.now()) {
      const tick = (now) => {
        const dt = Math.min(0.032, (now - last) / 1000);
        last = now;
        update(dt);
        draw();
        requestAnimationFrame(tick);
      };
      requestAnimationFrame(tick);
    }

    startBtn.addEventListener('click', () => {
      overlay.classList.add('hidden');
      resetGame();
      world.running = true;
      canvas.requestPointerLock?.();
    });

    window.addEventListener('keydown', (e) => {
      const key = e.key.toLowerCase();
      world.keys.add(key);
      if (key === ' ' && world.running) {
        e.preventDefault();
        fireBlast();
      }
    });

    window.addEventListener('keyup', (e) => {
      world.keys.delete(e.key.toLowerCase());
    });

    document.addEventListener('mousemove', (e) => {
      if (document.pointerLockElement === canvas && world.running) {
        world.player.yaw += e.movementX * 0.0028;
      }
    });

    canvas.addEventListener('click', () => {
      if (world.running) canvas.requestPointerLock?.();
    });

    canvas.addEventListener('mousedown', (e) => {
      if (e.button === 0 && world.running) fireBlast();
    });

    resetGame();
    draw();
    gameLoop();
  </script>
</body>
</html>
